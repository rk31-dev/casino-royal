<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Casino High & Low: Royal Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --color-gold: #FFD700;
            --color-gold-dim: #B8860B;
            --color-velour: #013220;
            --color-velour-light: #024b30;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--color-velour);
            background-image: radial-gradient(circle at center, var(--color-velour-light) 0%, var(--color-velour) 100%);
            color: white;
            overflow: hidden;
            touch-action: manipulation;
        }

        h1, .font-royal {
            font-family: 'Cinzel', serif;
        }

        /* 3D Card Styles */
        .perspective-1000 {
            perspective: 1000px;
        }
        
        .card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            text-align: center;
            transition: transform 0.6s cubic-bezier(0.4, 0.0, 0.2, 1);
            transform-style: preserve-3d;
        }
        
        .card-front, .card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            border-radius: 1rem;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        
        .card-front {
            background: white;
            color: black;
            transform: rotateY(0deg);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border: 2px solid #ddd;
        }
        
        .card-back {
            background: linear-gradient(135deg, #1a1a1a 0%, #2a2a2a 100%);
            transform: rotateY(180deg);
            display: flex;
            justify-content: center;
            align-items: center;
            border: 2px solid var(--color-gold-dim);
        }

        /* Pattern for card back */
        .pattern-grid {
            width: 100%;
            height: 100%;
            background-image: radial-gradient(var(--color-gold-dim) 1px, transparent 1px);
            background-size: 10px 10px;
            opacity: 0.3;
            border-radius: 0.9rem;
        }

        .card-flip {
            transform: rotateY(180deg);
        }

        /* UI Effects */
        .btn-3d {
            transition: all 0.1s;
            box-shadow: 0 5px 0 #000;
        }
        .btn-3d:active {
            transform: translateY(5px);
            box-shadow: 0 0 0 #000;
        }

        .neon-text {
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .joker-glow {
            animation: golden-pulse 1s infinite;
        }

        @keyframes golden-pulse {
            0% { box-shadow: 0 0 20px var(--color-gold); }
            50% { box-shadow: 0 0 50px var(--color-gold), 0 0 100px var(--color-gold); }
            100% { box-shadow: 0 0 20px var(--color-gold); }
        }

        #canvas-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
        }

        .suit-red { color: #e53e3e; }
        .suit-black { color: #2d3748; }
        .joker-text { 
            background: linear-gradient(to right, #bf953f, #fcf6ba, #b38728, #fbf5b7, #aa771c);
            -webkit-background-clip: text;
            color: transparent;
        }
    </style>
</head>
<body class="h-screen w-screen flex flex-col items-center justify-between py-6 select-none">

    <canvas id="canvas-layer"></canvas>

    <!-- Header -->
    <header class="text-center z-10">
        <h1 class="text-3xl md:text-5xl font-royal text-yellow-500 neon-text mb-2 tracking-wider">CASINO ROYAL</h1>
        <div class="flex justify-center gap-8 text-sm md:text-base font-semibold tracking-widest text-gray-300">
            <div>SCORE: <span id="score-display" class="text-white text-xl">0</span></div>
            <div>STREAK: <span id="streak-display" class="text-yellow-400 text-xl">0</span></div>
        </div>
    </header>

    <!-- Game Area -->
    <main class="flex-1 flex items-center justify-center w-full max-w-4xl gap-4 md:gap-12 px-4 z-10">
        
        <!-- Current Card -->
        <div class="perspective-1000 w-32 h-48 md:w-48 md:h-72">
            <div id="current-card" class="card-inner">
                <div class="card-front">
                    <!-- Content injected by JS -->
                </div>
                <div class="card-back">
                    <div class="pattern-grid"></div>
                </div>
            </div>
        </div>

        <!-- VS Indicator -->
        <div class="text-2xl font-royal text-yellow-600 opacity-50">VS</div>

        <!-- Deck / Next Card -->
        <div class="perspective-1000 w-32 h-48 md:w-48 md:h-72 cursor-pointer group" id="deck-area">
            <div id="next-card" class="card-inner card-flip">
                <div class="card-front">
                    <!-- Content injected by JS -->
                </div>
                <div class="card-back shadow-2xl group-hover:shadow-yellow-900/50 transition-shadow">
                    <div class="w-full h-full flex items-center justify-center bg-black/20 rounded-xl">
                        <span class="font-royal text-4xl text-yellow-600 opacity-80">ROYAL</span>
                    </div>
                    <div class="pattern-grid absolute top-0 left-0"></div>
                </div>
            </div>
        </div>

    </main>

    <!-- Controls -->
    <footer class="w-full max-w-md px-6 pb-8 z-10">
        <div id="controls" class="grid grid-cols-2 gap-6 opacity-50 pointer-events-none transition-opacity duration-300">
            <button id="btn-high" class="btn-3d bg-gradient-to-b from-green-600 to-green-800 text-white font-royal text-xl py-4 rounded-lg border-t border-green-400 shadow-lg relative overflow-hidden group">
                <span class="relative z-10">HIGH ‚ñ≤</span>
                <div class="absolute inset-0 bg-white/10 translate-y-full group-hover:translate-y-0 transition-transform"></div>
            </button>
            <button id="btn-low" class="btn-3d bg-gradient-to-b from-red-600 to-red-800 text-white font-royal text-xl py-4 rounded-lg border-t border-red-400 shadow-lg relative overflow-hidden group">
                <span class="relative z-10">LOW ‚ñº</span>
                <div class="absolute inset-0 bg-white/10 translate-y-full group-hover:translate-y-0 transition-transform"></div>
            </button>
        </div>
        <div id="message-area" class="h-8 text-center mt-4 text-yellow-200 font-medium tracking-wide min-h-[2rem]">
            Tap the deck to start
        </div>
    </footer>

    <script>
        /**
         * AUDIO SYSTEM
         * Procedural audio generation using Web Audio API
         */
        class SoundSystem {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.3; // Master volume
                this.masterGain.connect(this.ctx.destination);
            }

            async init() {
                if (this.ctx.state === 'suspended') {
                    await this.ctx.resume();
                }
            }

            playTone(freq, type, duration, startTime = 0) {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime + startTime);
                
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime + startTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + startTime + duration);

                osc.connect(gain);
                gain.connect(this.masterGain);
                
                osc.start(this.ctx.currentTime + startTime);
                osc.stop(this.ctx.currentTime + startTime + duration);
            }

            playNoise(duration) {
                const bufferSize = this.ctx.sampleRate * duration;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }

                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 1000;

                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                
                noise.start();
            }

            playFlip() {
                this.playNoise(0.15);
            }

            playWin() {
                // Major Triad Arpeggio
                this.playTone(523.25, 'sine', 0.3, 0);    // C5
                this.playTone(659.25, 'sine', 0.3, 0.1);  // E5
                this.playTone(783.99, 'sine', 0.6, 0.2);  // G5
            }

            playLoss() {
                // Discordant
                this.playTone(155.56, 'sawtooth', 0.4, 0); // Eb3
                this.playTone(146.83, 'sawtooth', 0.4, 0.1); // D3
            }

            playJoker() {
                // Magical sweep
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(1200, this.ctx.currentTime + 0.5);
                
                // Vibrato
                const lfo = this.ctx.createOscillator();
                lfo.frequency.value = 10;
                const lfoGain = this.ctx.createGain();
                lfoGain.gain.value = 50;
                lfo.connect(lfoGain);
                lfoGain.connect(osc.frequency);
                lfo.start();

                gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 1.5);

                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start();
                osc.stop(this.ctx.currentTime + 1.5);
            }

            playChip() {
                this.playTone(2000, 'sine', 0.1);
            }
        }

        /**
         * VISUAL SYSTEM
         * Canvas particles
         */
        class ParticleSystem {
            constructor() {
                this.canvas = document.getElementById('canvas-layer');
                this.ctx = this.canvas.getContext('2d');
                this.particles = [];
                this.resize();
                window.addEventListener('resize', () => this.resize());
                this.animate();
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            spawn(x, y, type = 'sparkle', count = 10) {
                for(let i=0; i<count; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10,
                        life: 1.0,
                        color: type === 'gold' ? '#FFD700' : '#FFFFFF',
                        size: Math.random() * 3 + 1,
                        type: type
                    });
                }
            }

            animate() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= 0.02;
                    p.vy += 0.2; // Gravity

                    this.ctx.globalAlpha = p.life;
                    this.ctx.fillStyle = p.color;
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    this.ctx.fill();

                    if (p.life <= 0) this.particles.splice(i, 1);
                }
                
                requestAnimationFrame(() => this.animate());
            }
        }

        /**
         * GAME LOGIC
         */
        const SUITS = ['‚ô†', '‚ô•', '‚ô¶', '‚ô£'];
        const RANKS = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        
        class Card {
            constructor(suit, rank, value, isJoker = false) {
                this.suit = suit;
                this.rank = rank;
                this.value = value;
                this.isJoker = isJoker;
            }

            getHTML() {
                if (this.isJoker) {
                    return `
                        <div class="text-6xl mb-2">üÉè</div>
                        <div class="font-royal text-2xl font-bold joker-text">JOKER</div>
                    `;
                }
                const colorClass = (this.suit === '‚ô•' || this.suit === '‚ô¶') ? 'suit-red' : 'suit-black';
                return `
                    <div class="absolute top-2 left-2 text-xl ${colorClass}">${this.rank}</div>
                    <div class="text-6xl ${colorClass}">${this.suit}</div>
                    <div class="absolute bottom-2 right-2 text-xl ${colorClass} rotate-180">${this.rank}</div>
                `;
            }
        }

        class Game {
            constructor() {
                this.deck = [];
                this.currentCard = null;
                this.nextCard = null;
                this.score = 0;
                this.streak = 0;
                this.state = 'IDLE'; // IDLE, PLAYING, ANIMATING
                
                this.sound = new SoundSystem();
                this.particles = new ParticleSystem();

                this.ui = {
                    currentCard: document.getElementById('current-card'),
                    nextCard: document.getElementById('next-card'),
                    score: document.getElementById('score-display'),
                    streak: document.getElementById('streak-display'),
                    controls: document.getElementById('controls'),
                    message: document.getElementById('message-area'),
                    deckArea: document.getElementById('deck-area'),
                    btnHigh: document.getElementById('btn-high'),
                    btnLow: document.getElementById('btn-low')
                };

                this.initListeners();
                this.createDeck();
            }

            createDeck() {
                this.deck = [];
                // Standard 52
                for (let s of SUITS) {
                    for (let i = 0; i < RANKS.length; i++) {
                        this.deck.push(new Card(s, RANKS[i], i + 2));
                    }
                }
                // 2 Jokers
                this.deck.push(new Card('Joker', 'Joker', 99, true));
                this.deck.push(new Card('Joker', 'Joker', 99, true));
                
                // Shuffle
                for (let i = this.deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
                }
            }

            draw() {
                if (this.deck.length === 0) this.createDeck();
                return this.deck.pop();
            }

            initListeners() {
                this.ui.deckArea.addEventListener('click', () => this.startGame());
                this.ui.btnHigh.addEventListener('click', () => this.guess('HIGH'));
                this.ui.btnLow.addEventListener('click', () => this.guess('LOW'));
            }

            async startGame() {
                if (this.state !== 'IDLE') return;
                
                await this.sound.init();
                this.sound.playFlip();
                
                this.state = 'PLAYING';
                this.currentCard = this.draw();
                // If first card is Joker, redraw (edge case)
                while(this.currentCard.isJoker) {
                    this.currentCard = this.draw();
                }

                this.renderCard(this.ui.currentCard, this.currentCard);
                this.ui.controls.classList.remove('opacity-50', 'pointer-events-none');
                this.ui.controls.classList.add('opacity-100');
                this.ui.message.textContent = "Make your choice...";
                this.ui.deckArea.classList.add('pointer-events-none'); // Disable deck click
            }

            async guess(choice) {
                if (this.state !== 'PLAYING') return;
                this.state = 'ANIMATING';

                // Prepare next card
                this.nextCard = this.draw();
                
                // Render hidden side of next card first (hacky but works for flip)
                const frontFace = this.ui.nextCard.querySelector('.card-front');
                frontFace.innerHTML = this.nextCard.getHTML();

                // Flip Animation
                this.sound.playFlip();
                this.ui.nextCard.classList.remove('card-flip'); // Show front

                await new Promise(r => setTimeout(r, 600));

                // Logic
                let win = false;
                let isJoker = this.nextCard.isJoker;

                if (isJoker) {
                    win = true;
                } else {
                    if (choice === 'HIGH' && this.nextCard.value > this.currentCard.value) win = true;
                    else if (choice === 'LOW' && this.nextCard.value < this.currentCard.value) win = true;
                }

                if (win) {
                    this.handleWin(isJoker);
                } else {
                    this.handleLoss();
                }
            }

            async handleWin(isJoker) {
                if (isJoker) {
                    this.sound.playJoker();
                    this.score += 500;
                    this.streak++;
                    this.ui.message.textContent = "JOKER BONUS! AUTOMATIC WIN!";
                    document.body.classList.add('joker-glow');
                    this.particles.spawn(window.innerWidth/2, window.innerHeight/2, 'gold', 50);
                    setTimeout(() => document.body.classList.remove('joker-glow'), 1000);
                } else {
                    this.sound.playWin();
                    this.score += 100 + (this.streak * 10);
                    this.streak++;
                    this.ui.message.textContent = "CORRECT!";
                    const rect = this.ui.nextCard.getBoundingClientRect();
                    this.particles.spawn(rect.left + rect.width/2, rect.top + rect.height/2, 'sparkle', 20);
                }

                this.updateUI();
                
                // Wait a bit then move next card to current
                await new Promise(r => setTimeout(r, 1500));
                
                // Reset for next round
                this.ui.nextCard.classList.add('card-flip'); // Hide back
                
                // If Joker, we need a new base card.
                if (isJoker) {
                    this.currentCard = this.draw();
                    while(this.currentCard.isJoker) this.currentCard = this.draw(); // Prevent double joker edge case
                } else {
                    this.currentCard = this.nextCard;
                }

                // Visual swap (simplified: just update current card content immediately after flip back)
                setTimeout(() => {
                    this.renderCard(this.ui.currentCard, this.currentCard);
                    this.state = 'PLAYING';
                    this.ui.message.textContent = "Next round...";
                }, 300);
            }

            handleLoss() {
                this.sound.playLoss();
                this.streak = 0;
                this.score = Math.max(0, this.score - 50); // Penalty
                this.ui.message.textContent = "GAME OVER";
                this.updateUI();

                // Shake effect
                document.body.style.transform = "translateX(5px)";
                setTimeout(() => document.body.style.transform = "translateX(-5px)", 50);
                setTimeout(() => document.body.style.transform = "translateX(0)", 100);

                // Reset Game
                setTimeout(() => {
                    this.state = 'IDLE';
                    this.ui.controls.classList.add('opacity-50', 'pointer-events-none');
                    this.ui.deckArea.classList.remove('pointer-events-none');
                    this.ui.message.textContent = "Tap deck to restart";
                    this.ui.nextCard.classList.add('card-flip');
                    
                    // Reset score on loss? Or just keep going? 
                    // "Game Over" usually implies reset. Let's reset score.
                    this.score = 0;
                    this.updateUI();
                }, 2000);
            }

            updateUI() {
                this.ui.score.textContent = this.score;
                this.ui.streak.textContent = this.streak;
            }

            renderCard(element, card) {
                const front = element.querySelector('.card-front');
                front.innerHTML = card.getHTML();
            }
        }

        // Start
        const game = new Game();

    </script>
</body>
</html>
